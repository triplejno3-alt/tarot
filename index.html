<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystic Tarot | Á•ûÁßòÂ°îÁΩó</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Markdown Renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        :root {
            --card-width: 200px;
            --card-height: 350px;
            --bg-dark: #050510;
            --accent-gold: #d4af37;
            --accent-glow: rgba(212, 175, 55, 0.6);
        }

        /* Intro Animation Class - if needed, but we will use JS interpolation */
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Cinzel', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            user-select: none;
        }

        /* Background Effects */
        #stars-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.8;
        }

        #fog-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background: linear-gradient(to top, rgba(10,10,30, 0.9), transparent);
            z-index: 1;
            pointer-events: none;
        }

        /* Main Game Container */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            perspective: 1200px; /* Increased perspective for deeper look */
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* 3D Scene for Cards */
        #scene {
            width: 100%;
            height: 60vh;
            position: relative;
            transform-style: preserve-3d;
            /* removed transition, we handle it in JS loop */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Card Styles */
        .card-wrapper {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            transform-style: preserve-3d;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.3s;
            cursor: pointer;
            border-radius: 15px;
        }

        .card-wrapper.selected {
            box-shadow: 0 0 30px var(--accent-glow);
            z-index: 100;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.8s;
            transform-style: preserve-3d;
            border-radius: 15px;
        }

        .card-wrapper.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 2px solid #333;
        }

        .card-back {
            background: repeating-linear-gradient(
                45deg,
                #1a1a2e,
                #1a1a2e 10px,
                #16213e 10px,
                #16213e 20px
            );
            background-image: url('https://www.transparenttextures.com/patterns/black-thread.png'); /* Fallback or simple pattern */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Elaborate back design using CSS pseudo-elements */
        .card-back::after {
            content: '‚ú¶';
            font-size: 3rem;
            color: rgba(212, 175, 55, 0.3);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-front {
            background-color: #fff;
            transform: rotateY(180deg);
            background-size: cover;
            background-position: center;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #header {
            text-align: center;
            text-shadow: 0 0 10px var(--accent-gold);
            margin-top: 20px;
        }
        
        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 5px;
            color: var(--accent-gold);
        }

        #status-text {
            text-align: center;
            font-size: 1.2rem;
            color: #aaa;
            margin-top: 10px;
            text-shadow: 0 0 5px black;
        }

        #controls {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            padding: 10px 30px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(0,0,0,0.5);
            border-radius: 30px;
        }

        .btn:hover {
            background: var(--accent-gold);
            color: #000;
            box-shadow: 0 0 20px var(--accent-glow);
        }

        #webcam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid var(--accent-gold);
            opacity: 0.5;
            border-radius: 10px;
            transform: scaleX(-1); /* Mirror */
            z-index: 100;
        }

        #interpretation-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            max-height: 80%;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid var(--accent-gold);
            padding: 30px;
            border-radius: 20px;
            color: #eee;
            overflow-y: auto;
            display: none; /* Hidden by default */
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            z-index: 50;
        }

        #interpretation-content {
            line-height: 1.6;
            font-size: 1.1rem;
        }
        
        #interpretation-content h3 {
            color: var(--accent-gold);
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        #token-input-container {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            z-index: 100;
        }
        
        #api-token {
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            width: 150px;
            transition: width 0.3s;
        }
        
        #api-token:focus {
            width: 300px;
            border-color: var(--accent-gold);
            outline: none;
        }

        /* Hand Gesture Guide */
            #gesture-guide {
                position: absolute;
                bottom: 150px;
                left: 50%;
                transform: translateX(-50%);
                display: none; /* Removed based on user request */
                gap: 20px;
                opacity: 0;
                transition: opacity 0.5s;
                pointer-events: none;
                width: 100%;
                justify-content: center;
            }
        
        .guide-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 30%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: rgba(212, 175, 55, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none; /* Ensure no blocking */
        }
        
        #zone-left { left: 0; justify-content: flex-start; padding-left: 50px; }
        #zone-right { right: 0; justify-content: flex-end; padding-right: 50px; }
        #zone-center { 
            left: 30%; 
            width: 40%; 
            align-items: flex-end;
            padding-bottom: 180px;
        }

        .guide-zone.active {
            opacity: 1;
            text-shadow: 0 0 20px var(--accent-gold);
        }
        
        /* New Pulse Animation */
        @keyframes pulseRing {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; border-width: 5px; }
            100% { transform: translate(-50%, -50%) scale(2.0); opacity: 0; border-width: 0px; }
        }
        
        .guide-icon {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 1px solid transparent;
        }
        
        .guide-icon.active {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 15px var(--accent-glow);
            transform: scale(1.2);
        }

        /* Cursor & Particles */
        #hand-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--accent-gold);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px var(--accent-glow);
            transition: width 0.2s, height 0.2s, background-color 0.2s;
            display: none; /* Hidden until hand detected */
        }
        
        /* Removed grabbing state as requested */
        /* #hand-cursor.grabbing { ... } */

        .cursor-trail {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--accent-glow);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0.8;
            animation: fadeTrail 0.5s forwards;
        }

        @keyframes fadeTrail {
            to { opacity: 0; transform: scale(0.2); }
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ffffff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 2001;
            animation: riseAndFade 0.8s ease-out forwards;
            box-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff;
        }

        @keyframes riseAndFade {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -150px) scale(0.2); opacity: 0; }
        }

        /* Charge Progress Bar */
        #charge-progress-container {
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin: 10px auto;
            overflow: hidden;
            display: none; /* Hidden by default */
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }
        
        #charge-progress-bar {
            width: 0%;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 10px #fff;
            transition: width 0.1s linear;
        }

        /* Charge Ring */
        #charge-ring {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 4px solid var(--accent-gold);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1001;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            transition: transform 0.1s linear;
        }

        /* Picked Card Zone */
        #picked-zone {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden initially */
            gap: 20px;
            z-index: 50;
            pointer-events: none;
        }

        .picked-slot {
            width: 100px;
            height: 175px;
            border: 2px dashed rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            transition: all 0.5s;
        }

        .picked-slot.filled {
            border-style: solid;
            border-color: var(--accent-gold);
            background: rgba(0,0,0,0.6);
        }

        .mini-card {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            animation: flyIn 0.5s ease-out;
        }

        @keyframes flyIn {
            from { transform: translateY(-300px) scale(1.5); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        /* Loading Spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--accent-gold);
            animation: spin 1s linear infinite;
            display: none;
            margin: 20px auto;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Settings Icon */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            color: var(--accent-gold);
            cursor: pointer;
            z-index: 1000;
            transition: transform 0.5s;
            pointer-events: auto; /* Enable clicks */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            border: 1px solid transparent;
        }
        #settings-btn:hover {
            transform: rotate(90deg);
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.1);
        }

        /* Settings Modal */
        #settings-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 3000;
            backdrop-filter: blur(5px);
        }
        .settings-content {
            background: #111;
            border: 2px solid var(--accent-gold);
            width: 90%;
            max-width: 400px;
            margin: 15vh auto;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            color: #eee;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .settings-content input {
            width: 80%;
            padding: 10px;
            margin: 20px 0;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 5px;
            font-size: 1rem;
        }
        .settings-content a {
            color: var(--accent-gold);
            text-decoration: underline;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #111;
        }
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

    </style>
</head>
<body>

    <!-- Background Canvas -->
    <canvas id="stars-canvas"></canvas>
    <div id="fog-layer"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="settings-btn">
            <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
            </svg>
        </div>
        <div id="hand-cursor"></div>
        <div id="charge-ring"></div>
        <div id="header">
            <h1>Á•ûÁßòÂ°îÁΩó</h1>
            <div id="status-text">Ê≠£Âú®ÂêØÂä®...</div>
            <div id="charge-progress-container">
                <div id="charge-progress-bar"></div>
            </div>
        </div>

        <div id="picked-zone">
            <div class="picked-slot" id="slot-0"></div>
            <div class="picked-slot" id="slot-1"></div>
            <div class="picked-slot" id="slot-2"></div>
        </div>

        <!-- Token Input Removed -->

        <div id="gesture-guide">
            <div id="zone-left" class="guide-zone">ÂêëÂè≥Êå•Âä® ‚û°</div>
            <div id="zone-right" class="guide-zone">‚¨Ö ÂêëÂ∑¶Êå•Âä®</div>
            <div id="zone-center" class="guide-zone">
                <div class="guide-icon" id="icon-select">‚úä</div>
                <div style="font-size: 1rem; margin-top: 10px; text-shadow: 0 0 5px black;">Êè°Êã≥ÈÄâÁâå</div>
            </div>
        </div>

        <div id="controls">
            <button id="start-btn" class="btn" style="display:none">ÂºÄÂßã‰ΩìÈ™å</button>
            <button id="interpret-btn" class="btn" style="display:none; background: linear-gradient(45deg, #d4af37, #f0e68c); color: #000; font-weight: bold; box-shadow: 0 0 20px rgba(212,175,55,0.6);">üîÆ Ëß£ËØªÂëΩËøê</button>
            <div class="spinner" id="loading-spinner"></div>
        </div>
    </div>

    <video id="webcam-preview" playsinline></video>

    <!-- 3D Scene -->
    <div id="game-container">
        <div id="scene">
            <!-- Cards will be injected here -->
        </div>
    </div>

    <!-- Interpretation Modal -->
    <div id="interpretation-modal">
        <h2 style="color: var(--accent-gold); text-align: center; margin-top: 0;">ÂëΩËøêÂêØÁ§∫</h2>
        <div id="interpretation-content"></div>
        <div style="text-align: center; margin-top: 30px;">
            <button class="btn" onclick="document.getElementById('interpretation-modal').style.display='none'">ÂÖ≥Èó≠</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="settings-content">
            <h2 style="color: var(--accent-gold);">API Key ÈÖçÁΩÆ ÔºàÊú¨Âú∞Â≠òÂÇ®Ôºâ</h2>
            <p>ËØ∑ËæìÂÖ•ÊÇ®ÁöÑ DeepSeek API Key ‰ª•ÂºÄÂêØ AI Ëß£ËØªÂäüËÉΩ„ÄÇ</p>
            <p style="font-size: 0.9rem; color: #aaa;">
                ËøòÊ≤°Êúâ KeyÔºüÂâçÂæÄ <a href="https://platform.deepseek.com/api_keys" target="_blank">DeepSeek Platform</a> Ëé∑Âèñ„ÄÇ
            </p>
            <input type="password" id="api-token-input" placeholder="sk-...">
            <div id="token-status" style="font-size: 0.8rem; margin: 10px 0; min-height: 1.2em;"></div>
            <button id="save-settings-btn" class="btn">‰øùÂ≠òÈÖçÁΩÆ</button>
            <button id="close-settings-btn" class="btn" style="background: transparent; border: 1px solid #444; margin-top: 10px;">ÂÖ≥Èó≠</button>
        </div>
    </div>

    <script>
        // --- 1. Card Data & Configuration ---
        const ASSETS_PATH = 'assets/tarot/pkt/';
        
        // Helper to generate full card list
        const generateCards = () => {
            const cards = [];
            
            // Major Arcana
            const majorNames = [
                "The Fool", "The Magician", "The High Priestess", "The Empress", "The Emperor", 
                "The Hierophant", "The Lovers", "The Chariot", "Strength", "The Hermit", 
                "Wheel of Fortune", "Justice", "The Hanged Man", "Death", "Temperance", 
                "The Devil", "The Tower", "The Star", "The Moon", "The Sun", 
                "Judgement", "The World"
            ];
            
            majorNames.forEach((name, i) => {
                const id = `ar${String(i).padStart(2, '0')}`;
                cards.push({ id, name, type: 'major', img: `${ASSETS_PATH}${id}.jpg` });
            });

            // Minor Arcana
            const suits = [
                { code: 'wa', name: 'Wands' },
                { code: 'cu', name: 'Cups' },
                { code: 'sw', name: 'Swords' },
                { code: 'pe', name: 'Pentacles' }
            ];
            
            const ranks = [
                { code: 'ac', name: 'Ace' },
                { code: '02', name: 'Two' }, { code: '03', name: 'Three' }, { code: '04', name: 'Four' },
                { code: '05', name: 'Five' }, { code: '06', name: 'Six' }, { code: '07', name: 'Seven' },
                { code: '08', name: 'Eight' }, { code: '09', name: 'Nine' }, { code: '10', name: 'Ten' },
                { code: 'pa', name: 'Page' }, { code: 'kn', name: 'Knight' }, { code: 'qu', name: 'Queen' }, { code: 'ki', name: 'King' }
            ];

            suits.forEach(suit => {
                ranks.forEach(rank => {
                    const id = `${suit.code}${rank.code}`;
                    cards.push({
                        id,
                        name: `${rank.name} of ${suit.name}`,
                        type: 'minor',
                        img: `${ASSETS_PATH}${id}.jpg`
                    });
                });
            });

            return cards;
        };

        const FULL_DECK = generateCards();
        let currentDeck = [];
        let pickedCards = []; // { card, reversed, position }
        
        // --- 2. Game State & Logic ---
        const STATE = {
            IDLE: 'IDLE',
            INTRO: 'INTRO',
            PICKING: 'PICKING',
            REVEALING: 'REVEALING',
            INTERPRETING: 'INTERPRETING'
        };

        let currentState = STATE.IDLE;
        
        // Navigation State
        let currentIndex = 0;   // Current float index (physics object)
        let velocity = 0;       // Current scroll velocity
        let isDragging = false; // Is the user actively moving?
        
        // --- 3. 3D Scene & Rendering ---
        const scene = document.getElementById('scene');
        
        function initStars() {
            const canvas = document.getElementById('stars-canvas');
            const ctx = canvas.getContext('2d');
            
            let width, height, stars = [];
            
            function resize() {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                stars = [];
                for(let i=0; i<200; i++) {
                    stars.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: Math.random() * 2,
                        opacity: Math.random(),
                        speed: Math.random() * 0.5
                    });
                }
            }
            
            function animate() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'white';
                
                stars.forEach(star => {
                    ctx.globalAlpha = star.opacity;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    star.y -= star.speed;
                    if(star.y < 0) star.y = height;
                    
                    // Twinkle
                    if(Math.random() > 0.95) star.opacity = Math.random();
                });
                
                requestAnimationFrame(animate);
            }
            
            window.addEventListener('resize', resize);
            resize();
            animate();
        }

        // Shuffle Array
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createCardElement(card, index) {
            const wrapper = document.createElement('div');
            wrapper.className = 'card-wrapper';
            wrapper.dataset.index = index;
            
            const inner = document.createElement('div');
            inner.className = 'card-inner';
            
            const back = document.createElement('div');
            back.className = 'card-face card-back';
            
            const front = document.createElement('div');
            front.className = 'card-face card-front';
            front.style.backgroundImage = `url('${card.img}')`;
            
            inner.appendChild(back);
            inner.appendChild(front);
            wrapper.appendChild(inner);
            
            return wrapper;
        }

        function renderDeck() {
            scene.innerHTML = '';
            
            // Render logic based on state
            if (currentState === STATE.PICKING || currentState === STATE.INTRO) {
                // Render a fan or spread of cards
                // For simplicity and "coolness", we use a horizontal carousel
                
                currentDeck.forEach((card, i) => {
                    const el = createCardElement(card, i);
                    scene.appendChild(el);
                });
                updateCardPositions();
            } else if (currentState === STATE.REVEALING || currentState === STATE.INTERPRETING) {
                // Render only picked cards centered
                pickedCards.forEach((item, i) => {
                    const el = createCardElement(item.card, i);
                    // Add picked specific styles if needed
                    el.classList.add('picked-card');
                    // Immediately flip if revealed
                    // Logic handled in updatePickedPositions
                    scene.appendChild(el);
                });
                updatePickedPositions();
            }
        }

        function updateCardPositions() {
            if (currentState !== STATE.PICKING && currentState !== STATE.INTRO) return;

            const cards = document.querySelectorAll('.card-wrapper');
            const width = window.innerWidth;
            
            // Responsive Layout Calculation
            // Base gap + factor of screen width
            // This ensures on wide screens cards are spread out more
            const gap = Math.min(Math.max(220, width * 0.18), 400); 
            
            // Calculate how many cards to show based on screen width
            // Due to Z-depth, cards shrink, so we need more margin
            // If gap is 300, and width is 1920 (half 960), we need ~3.2 cards.
            // But Z-depth makes them squeeze. Let's be generous.
            const visibleSideCount = Math.ceil((width / 2) / (gap * 0.5)) + 3;
            
            cards.forEach((card, i) => {
                // Check if card is already picked
                if (card.classList.contains('picked')) {
                    return; // Skip positioning logic for picked cards
                }

                const dist = i - currentIndex;
                
                if (Math.abs(dist) > visibleSideCount) {
                    card.style.display = 'none';
                    return;
                } else {
                    card.style.display = 'block';
                }

                const x = dist * gap;
                // Reduce Z-depth dropoff to keep peripheral cards larger/closer
                const z = -Math.pow(Math.abs(dist), 1.3) * 50; 
                
                // Reduced rotation to keep back visible (prevent face peeking)
                // Clamp rotation to max 45 degrees
                let rotateY = dist * 5; 
                if (rotateY > 45) rotateY = 45;
                if (rotateY < -45) rotateY = -45;
                
                let scale = 1;
                const isSelected = Math.round(currentIndex) === i;
                
                if (Math.abs(dist) < 0.5) {
                    scale = 1.2 - Math.abs(dist) * 0.4;
                    card.style.zIndex = 1000;
                } else {
                    // Less aggressive scaling down for side cards
                    scale = 1 - Math.min(Math.abs(dist) * 0.08, 0.4);
                    card.style.zIndex = 1000 - Math.floor(Math.abs(dist) * 10);
                }
                
                if (isSelected) {
                     card.classList.add('selected');
                } else {
                     card.classList.remove('selected');
                }
                
                card.style.transform = `translateX(${x}px) translateZ(${z}px) rotateY(${rotateY}deg) scale(${scale})`;
            });
        }

        function updatePickedPositions() {
            const cards = document.querySelectorAll('.card-wrapper');
            
            // Responsive spacing for picked cards
            const width = window.innerWidth;
            const spread = Math.min(width * 0.3, 400); // Dynamic spread
            
            const positions = [-spread, 0, spread];
            const labels = ["ËøáÂéª", "Áé∞Âú®", "Êú™Êù•"];
            
            cards.forEach((card, i) => {
                const x = positions[i];
                // If this card is revealed, flip it
                if (i < pickedCards.length) {
                    const picked = pickedCards[i];
                    // Reveal animation
                    setTimeout(() => {
                        card.classList.add('flipped');
                    }, i * 500 + 500); // Staggered reveal
                }
                
                card.style.transform = `translateX(${x}px) scale(1.1)`;
                card.style.zIndex = 10;
                
                // Add label if not exists
                if (!card.querySelector('.label')) {
                    const label = document.createElement('div');
                    label.className = 'label';
                    label.innerText = labels[i];
                    label.style.position = 'absolute';
                    label.style.bottom = '-40px';
                    label.style.width = '100%';
                    label.style.textAlign = 'center';
                    label.style.color = '#d4af37';
                    label.style.textShadow = '0 0 5px black';
                    label.style.fontSize = '1.2rem';
                    card.appendChild(label);
                }
            });
        }

        // --- 4. Controls & Hand Gestures ---
        let lastHandX = -1;
        let lastHandY = -1; // Track Y for cursor
        
        // Selection State
        let fistHoldStart = 0;
        let isFistHeld = false;
        const SELECTION_HOLD_TIME = 1000; // 1 second as requested

        // Interpretation Gesture State
        let isPalmHeld = false;
        let palmHoldStart = 0;
        const INTERPRET_HOLD_TIME = 1500;

        // Physics Constants
        const FRICTION = 0.92;
        const SENSITIVITY = 1.0; // Reduced for slower, controlled scrolling
        const MAX_VELOCITY = 0.25; // Lower cap speed
        
        function isFist(landmarks) {
            // Check fingertips (8, 12, 16, 20) distance to wrist (0)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            
            tips.forEach(idx => {
                const tip = landmarks[idx];
                const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                avgDist += d;
            });
            avgDist /= tips.length;
            
            // Threshold for fist (tuned for normalized coordinates)
            return avgDist < 0.23; 
        }

        function isOpenPalm(landmarks) {
             // Check fingertips (8, 12, 16, 20) distance to wrist (0)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            
            tips.forEach(idx => {
                const tip = landmarks[idx];
                const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                avgDist += d;
            });
            avgDist /= tips.length;
            
            // Threshold for open palm (fingers extended)
            return avgDist > 0.4; 
        }

        function spawnChargeParticles(rect) {
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            
            // Spawn multiple particles
            for(let i=0; i<2; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                
                // Random offset within card area
                const ox = (Math.random() - 0.5) * rect.width * 0.9;
                const oy = (Math.random() - 0.5) * rect.height * 0.9;
                
                p.style.left = (x + ox) + 'px';
                p.style.top = (y + oy) + 'px';
                
                // Varied properties
                const size = 2 + Math.random() * 6;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                
                if(Math.random() > 0.6) {
                    p.style.background = 'var(--accent-gold)';
                    p.style.boxShadow = '0 0 8px var(--accent-gold)';
                }
                
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 800);
            }
        }

        function spawnInterpretationParticles() {
            for (let i = 0; i < 5; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                
                const size = 3 + Math.random() * 8;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                
                p.style.background = 'var(--accent-gold)';
                p.style.boxShadow = '0 0 10px var(--accent-gold)';
                p.style.opacity = '0.8';
                p.style.zIndex = '9999';
                
                // Animation: Float up
                p.animate([
                    { transform: 'translateY(0) scale(1)', opacity: 0.8 },
                    { transform: `translateY(-100px) scale(0)`, opacity: 0 }
                ], {
                    duration: 1000 + Math.random() * 1000,
                    easing: 'ease-out'
                });
                
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 2000);
            }
        }

        function spawnTrail(x, y) {
            const trail = document.createElement('div');
            trail.className = 'cursor-trail';
            trail.style.left = x + 'px';
            trail.style.top = y + 'px';
            // Random colors for coolness
            const hue = (Date.now() / 10) % 360;
            trail.style.background = `hsla(${hue}, 80%, 60%, 0.8)`;
            trail.style.boxShadow = `0 0 10px hsla(${hue}, 80%, 60%, 0.8)`;
            document.body.appendChild(trail);
            setTimeout(() => trail.remove(), 500);
        }

        function updateChargeVisuals(isActive, x, y, progress) {
            const ring = document.getElementById('charge-ring');
            // Disable ring visual as requested (red circle)
            ring.style.opacity = '0';
            ring.style.display = 'none';
            return;
            
            /* Previous logic disabled
            if (!isActive) {
                ring.style.opacity = '0';
                ring.style.transform = `translate(-50%, -50%) scale(0)`;
                return;
            }
            
            ring.style.left = x + 'px';
            ring.style.top = y + 'px';
            ring.style.opacity = '1';
            // Scale from 0.5 to 1.5 based on progress
            const scale = 0.5 + progress; 
            ring.style.transform = `translate(-50%, -50%) scale(${scale})`;
            
            // Change color based on progress
            const r = 212 + (255-212)*progress;
            const g = 175 - 175*progress; // Turn redder? Or whiter? Let's go Gold to White
            const b = 55 + (255-55)*progress;
            ring.style.borderColor = `rgb(${r},${g},${b})`;
            */
        }

        function handleGesture(handLandmarks) {
            // Allow processing in INTERPRETING and IDLE state too
            if (currentState !== STATE.PICKING && currentState !== STATE.INTERPRETING && currentState !== STATE.IDLE) return;
            
            const palm = handLandmarks[9]; 
            const x = palm.x; 
            const y = palm.y;

            // Initialize lastHandX if needed
            if (lastHandX === -1) {
                lastHandX = x;
                lastHandY = y;
                return;
            }

            // Update Cursor Visuals
            const cursor = document.getElementById('hand-cursor');
            const screenX = (1 - x) * window.innerWidth; // Mirror X
            const screenY = y * window.innerHeight;
            
            cursor.style.display = 'block';
            cursor.style.left = screenX + 'px';
            cursor.style.top = screenY + 'px';

            // Always spawn trail for "cool" factor when moving
            const distMoved = Math.sqrt(Math.pow(x - lastHandX, 2) + Math.pow(y - lastHandY, 2));
            if (distMoved > 0.005) {
                spawnTrail(screenX, screenY);
            }

            // --- START & INTERPRETATION LOGIC ---
            if (currentState === STATE.IDLE || currentState === STATE.INTERPRETING) {
                const progressContainer = document.getElementById('charge-progress-container');
                const progressBar = document.getElementById('charge-progress-bar');
                
                if (isOpenPalm(handLandmarks)) {
                    if (!isPalmHeld) {
                        isPalmHeld = true;
                        palmHoldStart = Date.now();
                        // Show progress bar
                        progressContainer.style.display = 'block';
                        progressBar.style.width = '0%';
                    }
                    
                    const elapsed = Date.now() - palmHoldStart;
                    const progress = Math.min(elapsed / INTERPRET_HOLD_TIME, 1.0);
                    
                    // Visuals
                    if (Math.random() < 0.5) spawnInterpretationParticles();
                    
                    // Update Progress Bar
                    progressBar.style.width = (progress * 100) + '%';
                    
                    if (elapsed > INTERPRET_HOLD_TIME) {
                        // Trigger Action
                        if (currentState === STATE.IDLE) {
                            startGame();
                        } else {
                            const token = localStorage.getItem('deepseek_token');
                            if (token) {
                                 getAIInterpretation(token);
                            }
                        }
                        
                        // Reset vars but keep state (modal will handle overlay)
                        isPalmHeld = false;
                        palmHoldStart = 0;
                        progressContainer.style.display = 'none';
                    }
                } else {
                    if (isPalmHeld) {
                        isPalmHeld = false;
                        palmHoldStart = 0;
                        
                        // Reset Visuals
                        progressContainer.style.display = 'none';
                        progressBar.style.width = '0%';

                        if (currentState === STATE.IDLE) {
                             document.getElementById('status-text').innerText = "Âº†ÂºÄ‰Ω†ÁöÑ‰∫îÊåáÂºÄÂßã";
                        } else {
                             document.getElementById('status-text').innerText = "Âº†ÂºÄ‰Ω†ÁöÑ‰∫îÊåáÔºåËß£ËØªÁâåÈù¢";
                        }
                    }
                }
                lastHandX = x;
                lastHandY = y;
                return; // Skip picking logic
            }

            // --- ZONE BASED LOGIC (Replaced Movement Logic) ---
            const width = window.innerWidth;
            let targetV = 0;
            const MAX_SCROLL_SPEED = 0.2; // Max speed at edge of screen
            
            if (screenX < width * 0.33) {
                // LEFT ZONE (0 - 1/3)
                // Speed increases as we get closer to the left edge (0)
                const distFromCenter = (width * 0.33) - screenX;
                const maxDist = width * 0.33;
                const intensity = Math.min(distFromCenter / maxDist, 1.0); // 0 to 1
                
                targetV = -intensity * MAX_SCROLL_SPEED;
                highlightDirection('left');
            } else if (screenX > width * 0.66) {
                // RIGHT ZONE (2/3 - 1)
                // Speed increases as we get closer to the right edge (width)
                const distFromCenter = screenX - (width * 0.66);
                const maxDist = width * 0.34;
                const intensity = Math.min(distFromCenter / maxDist, 1.0); // 0 to 1
                
                targetV = intensity * MAX_SCROLL_SPEED;
                highlightDirection('right');
            } else {
                // CENTER ZONE (1/3 - 2/3)
                // Stop Scrolling
                targetV = 0;
                
                // Only clear highlights if not selecting
                if (!isFistHeld) resetHighlights();
            }
            
            // Smoothly interpolate velocity towards target
            // This prevents jerky starts/stops
            velocity = velocity * 0.8 + targetV * 0.2;

            // --- SELECTION LOGIC (Middle 1/3 + 1s Hold) ---
            const inCenterZone = screenX > width * 0.33 && screenX < width * 0.66;
            const fistDetected = isFist(handLandmarks);

            if (fistDetected && inCenterZone) {
                // Cursor stays same shape/color
                
                if (!isFistHeld) {
                    // Start Holding
                    isFistHeld = true;
                    fistHoldStart = Date.now();
                    highlightDirection('select');
                }
                
                // Calculate Progress
                const elapsed = Date.now() - fistHoldStart;
                const progress = Math.min(elapsed / SELECTION_HOLD_TIME, 1.0);
                
                // Glow Effect on Target Card
                const targetIdx = Math.round(currentIndex);
                const cards = document.querySelectorAll('.card-wrapper');
                cards.forEach(card => {
                    if (parseInt(card.dataset.index) === targetIdx) {
                        // White glow increasing with progress - Intensified
                        const glowSize = 30 + (progress * 100);
                        const glowAlpha = 0.8 + (progress * 0.2); // Starts bright, stays bright
                        // Multiple layers for intense glow
                        card.style.boxShadow = `
                            0 0 ${glowSize}px rgba(255, 255, 255, ${glowAlpha}),
                            0 0 ${glowSize * 0.5}px rgba(255, 255, 255, 1),
                            inset 0 0 30px rgba(255, 255, 255, 0.5)
                        `;
                        card.style.transform += ` scale(${1.2 + progress * 0.15})`; // Slight swell
                        card.style.filter = `brightness(${1 + progress * 1.5})`; // Make it blindingly bright
                        card.style.zIndex = 2000; // Ensure on top
                        
                        // Spawn Particles
                        spawnChargeParticles(card.getBoundingClientRect());
                        
                    } else {
                         // Reset others if needed, though usually handled in updateCardPositions
                         // We should let updateCardPositions handle base state, but here we override.
                         card.style.filter = ''; // Reset filter
                         card.style.boxShadow = ''; // Reset shadow
                    }
                });

                updateChargeVisuals(true, screenX, screenY, progress);
                
                if (elapsed > SELECTION_HOLD_TIME) {
                    // Trigger Selection
                    selectCard();
                    
                    // Reset
                    isFistHeld = false;
                    fistHoldStart = 0;
                    updateChargeVisuals(false);
                    
                    // Cleanup any remaining glow immediately on select (or keep it as feedback?)
                    // Actually selectCard hides the card, so we are fine.
                    
                    // Success Burst
                    const ring = document.createElement('div');
                    ring.style.position = 'absolute';
                    ring.style.left = screenX + 'px';
                    ring.style.top = screenY + 'px';
                    ring.style.width = '100px';
                    ring.style.height = '100px';
                    ring.style.border = '4px solid white';
                    ring.style.borderRadius = '50%';
                    ring.style.transform = 'translate(-50%, -50%)';
                    ring.style.animation = 'pulseRing 0.5s ease-out'; 
                    document.body.appendChild(ring);
                    setTimeout(() => ring.remove(), 500);
                }
                
            } else {
                // cursor.classList.remove('grabbing');
                if (isFistHeld) {
                    // Cancelled
                    isFistHeld = false;
                    fistHoldStart = 0;
                    updateChargeVisuals(false);
                    resetHighlights();
                    
                    // Reset card styles immediately
                    const cards = document.querySelectorAll('.card-wrapper');
                    cards.forEach(card => {
                        card.style.filter = '';
                        card.style.boxShadow = '';
                    });
                }
            }
            
            lastHandX = x;
            lastHandY = y;
        }

        let targetIndex = 0; // Target for intro animation

        function gameLoop() {
            if (currentState === STATE.INTRO) {
                // Smoothly interpolate currentIndex to targetIndex
                const dist = targetIndex - currentIndex;
                // Exponential ease out
                currentIndex += dist * 0.05;
                
                // Check if close enough to stop intro
                if (Math.abs(dist) < 0.1) {
                    currentIndex = targetIndex;
                    currentState = STATE.PICKING;
                    document.getElementById('status-text').innerText = "Êè°Êã≥ÈÄâ‰∏≠‰Ω†ÁöÑÂëΩËøê‰πãÁâå";
                    // Show picked zone slots
                    document.getElementById('picked-zone').style.display = 'flex';
                }
                updateCardPositions();
            }
            
            if (currentState === STATE.PICKING) {
                // Apply Velocity
                currentIndex += velocity;
                
                // Apply Friction
                velocity *= FRICTION;
                
                // Stop if very slow
                if (Math.abs(velocity) < 0.0001) velocity = 0;

                // Bounds Checking with Bounce/Damping
                if (currentIndex < 0) {
                    currentIndex = 0;
                    velocity = -velocity * 0.5; // Bounce
                }
                if (currentIndex > currentDeck.length - 1) {
                    currentIndex = currentDeck.length - 1;
                    velocity = -velocity * 0.5; // Bounce
                }
                
                updateCardPositions();
            }
            requestAnimationFrame(gameLoop);
        }

        function highlightDirection(dir) {
            resetHighlights();
            if (dir === 'left') document.getElementById('zone-right').classList.add('active'); // Visual Right is Swipe Left source?
            // Actually let's just highlight the side corresponding to movement
            // Hand moves Left -> Highlight Left Zone
            if (dir === 'left') document.getElementById('zone-left').classList.add('active'); // Wait, Left Zone is visually on Left
            if (dir === 'right') document.getElementById('zone-right').classList.add('active');
            if (dir === 'select') {
                document.getElementById('zone-center').classList.add('active');
                document.getElementById('icon-select').classList.add('active');
            }
        }
        
        function resetHighlights() {
            document.getElementById('zone-left').classList.remove('active');
            document.getElementById('zone-right').classList.remove('active');
            document.getElementById('zone-center').classList.remove('active');
            document.getElementById('icon-select').classList.remove('active');
        }

        // Start Loop
        requestAnimationFrame(gameLoop);

        function navigateDeck(dir) {
            // Keyboard support updates velocity for consistency
            velocity += dir * 0.1;
            if (dir < 0) highlightDirection('left');
            if (dir > 0) highlightDirection('right');
            setTimeout(resetHighlights, 200);
        }

        function selectCard() {
            if (currentState !== STATE.PICKING) return;
            
            // Select the card currently at the integer center
            const selectedIdxInt = Math.round(currentIndex);
            
            // Check if valid
            if (selectedIdxInt < 0 || selectedIdxInt >= currentDeck.length) return;
            
            // Check if already picked (though we remove them from flow usually)
            // But with splicing logic, we need to be careful.
            // New logic: We DON'T splice. We just mark them.
            
            const selectedCard = currentDeck[selectedIdxInt];
            
            // Check if this specific card ID is already picked
            if (pickedCards.some(p => p.card.id === selectedCard.id)) return;
            
            // Mark visually in the deck
            const cardElements = document.querySelectorAll('.card-wrapper');
            let sourceRect = null;
            
            cardElements.forEach(el => {
                if (parseInt(el.dataset.index) === selectedIdxInt) {
                    el.classList.add('picked');
                    el.style.opacity = '0'; // Hide from deck
                    sourceRect = el.getBoundingClientRect();
                }
            });

            // Add to picked list
            const isReversed = Math.random() < 0.3;
            pickedCards.push({
                card: selectedCard,
                reversed: isReversed,
                position: ['ËøáÂéª', 'Áé∞Âú®', 'Êú™Êù•'][pickedCards.length]
            });

            // Update Status
            document.getElementById('status-text').innerText = `Â∑≤ÈÄâÂç°Áâå ${pickedCards.length}/3`;

            // Animate to Slot
            const slotIndex = pickedCards.length - 1;
            const slot = document.getElementById(`slot-${slotIndex}`);
            if (slot) {
                slot.classList.add('filled');
                const miniCard = document.createElement('div');
                miniCard.className = 'mini-card';
                miniCard.style.backgroundImage = `url('https://www.transparenttextures.com/patterns/black-scales.png')`; // Back of card
                // Add star effect or something
                miniCard.innerHTML = `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:2rem;color:rgba(212,175,55,0.5);">‚ú¶</div>`;
                slot.appendChild(miniCard);
            }

            if (pickedCards.length === 3) {
                setTimeout(finishPicking, 1000);
            }
        }

        function finishPicking() {
            currentState = STATE.REVEALING;
            document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤Êè≠Á§∫";
            document.getElementById('gesture-guide').style.opacity = '0';
            
            // Hide picked zone (we will move them to center scene)
            document.getElementById('picked-zone').style.opacity = '0';
            
            renderDeck(); // Will switch to reveal layout
            
            setTimeout(() => {
                // All cards revealed after animation
                currentState = STATE.INTERPRETING;
                const token = localStorage.getItem('deepseek_token');
                if (token) {
                    // Gesture instruction instead of button
                    document.getElementById('status-text').innerText = "Âº†ÂºÄ‰∫îÊåáÔºåÂºÄÂêØÂëΩËøêËß£ËØª";
                } else {
                    document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤ÂÆö (ÈÖçÁΩÆ Token ÂèØËé∑Âèñ AI Ëß£ËØª)";
                }
            }, 2500);
        }
        
        function showSimpleMeaning() {
             const modal = document.getElementById('interpretation-modal');
             const content = document.getElementById('interpretation-content');
             
             let html = '';
             pickedCards.forEach(p => {
                 html += `<h3>${p.position}: ${p.card.name} ${p.reversed ? '(ÈÄÜ‰Ωç)' : '(Ê≠£‰Ωç)'}</h3>`;
                 html += `<p>ËøôÂº†ÁâåË±°ÂæÅÁùÄ‰Ω† ${p.position} ÁöÑÂÖ≥ÈîÆÂΩ±Âìç„ÄÇ(ÈÖçÁΩÆ AI ‰ª§Áâå‰ª•Ëé∑ÂèñËØ¶ÁªÜËß£ËØª)</p>`;
             });
             
             content.innerHTML = html;
             modal.style.display = 'block';
        }

        // --- 5. MediaPipe Setup ---
        async function setupCamera() {
            const videoElement = document.getElementById('webcam-preview');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handleGesture(results.multiHandLandmarks[0]);
                }
            });
            
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            return camera;
        }

        // --- 6. AI Integration ---
        async function getAIInterpretation(token) {
            document.getElementById('loading-spinner').style.display = 'block';
            
            const prompt = `‰Ω†ÊòØ‰∏Ä‰ΩçÁ≤æÈÄöÁ•ûÁßòÂ≠¶„ÄÅËç£Ê†ºÂøÉÁêÜÂ≠¶‰∏éË±°ÂæÅÁ¨¶Âè∑ÁöÑËµÑÊ∑±Â°îÁΩóÂç†ÂçúÂ∏à„ÄÇÊàëÊäΩÂèñ‰∫Ü‰∏âÂº†ÁâåÔºåÂàÜÂà´‰ª£Ë°®‚ÄúËøáÂéª‚Äù„ÄÅ‚ÄúÁé∞Âú®‚ÄùÂíå‚ÄúÊú™Êù•‚ÄùÔºàÊó∂Èó¥‰πãÊµÅÁâåÈòµÔºâ„ÄÇ
            
            1. ËøáÂéª (The Past): ${pickedCards[0].card.name} (${pickedCards[0].reversed ? 'ÈÄÜ‰Ωç (Reversed)' : 'Ê≠£‰Ωç (Upright)'})
            2. Áé∞Âú® (The Present): ${pickedCards[1].card.name} (${pickedCards[1].reversed ? 'ÈÄÜ‰Ωç (Reversed)' : 'Ê≠£‰Ωç (Upright)'})
            3. Êú™Êù• (The Future): ${pickedCards[2].card.name} (${pickedCards[2].reversed ? 'ÈÄÜ‰Ωç (Reversed)' : 'Ê≠£‰Ωç (Upright)'})
            
            ËØ∑Áî®‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ‰∏∫ÊàëËß£ËØªËøôÁªÑÁâåÈòµ„ÄÇ‰Ω†ÁöÑËØ≠Ë®ÄÈ£éÊ†ºÂ∫îÂΩìÁ•ûÁßò„ÄÅ‰ºòÈõÖ„ÄÅÂØåÊúâÂì≤ÁêÜ‰∏îÂÖÖÊª°ÂêåÁêÜÂøÉÔºå‰ªø‰ΩõÂú®‰∏éÁÅµÈ≠ÇÂØπËØù„ÄÇ
            
            ËØ∑Êåâ‰ª•‰∏ã Markdown Ê†ºÂºèËæìÂá∫Ôºö
            
            ### üîÆ Êï¥‰ΩìÂêØÁ§∫
            ÔºàÁî®‰∏ÄÊÆµÂÖÖÊª°ÊÑèÂ¢ÉÁöÑÂºïË®ÄÔºåÊÄªÁªìËøô‰∏âÂº†ÁâåÂÖ±ÂêåÊûÑÊàêÁöÑËÉΩÈáèÂú∫ÊàñÊ†∏ÂøÉ‰∏ªÈ¢òÔºå100Â≠óÂ∑¶Âè≥Ôºâ
            
            ---
            
            ### üÉè ÁâåÈù¢Ê∑±Â∫¶Ëß£Êûê
            
            #### 1. ËøáÂéª‰πãÂõ†Ôºö${pickedCards[0].card.name} ${pickedCards[0].reversed ? '(ÈÄÜ)' : '(Ê≠£)'}
            *   **ÁâåÈù¢ÊÑèË±°**ÔºöÔºàÁÆÄËø∞ÁâåÈù¢ËßÜËßâÂÖÉÁ¥†ÂèäÂÖ∂Ë±°ÂæÅÊÑè‰πâÔºâ
            *   **Ê†∏ÂøÉÂê´‰πâ**ÔºöÔºàËß£ËØªËøôÂº†ÁâåÂú®‚ÄúËøáÂéª‚Äù‰ΩçÁΩÆÁöÑÂê´‰πâÔºåÂÆÉÂ¶Ç‰ΩïÂΩ±Âìç‰∫ÜÂΩì‰∏ãÁöÑÂ±ÄÈù¢Ôºâ
            
            #### 2. ÂΩì‰∏ã‰πãÂ¢ÉÔºö${pickedCards[1].card.name} ${pickedCards[1].reversed ? '(ÈÄÜ)' : '(Ê≠£)'}
            *   **ÁâåÈù¢ÊÑèË±°**ÔºöÔºàÁÆÄËø∞ÁâåÈù¢ËßÜËßâÂÖÉÁ¥†ÂèäÂÖ∂Ë±°ÂæÅÊÑè‰πâÔºâ
            *   **Ê†∏ÂøÉÂê´‰πâ**ÔºöÔºàËß£ËØªËøôÂº†ÁâåÂú®‚ÄúÁé∞Âú®‚Äù‰ΩçÁΩÆÁöÑÂê´‰πâÔºåÊè≠Á§∫ÂΩìÂâçÈù¢‰∏¥ÁöÑÊåëÊàòÊàñÊú∫ÈÅáÔºâ
            
            #### 3. Êú™Êù•‰πãÊûúÔºö${pickedCards[2].card.name} ${pickedCards[2].reversed ? '(ÈÄÜ)' : '(Ê≠£)'}
            *   **ÁâåÈù¢ÊÑèË±°**ÔºöÔºàÁÆÄËø∞ÁâåÈù¢ËßÜËßâÂÖÉÁ¥†ÂèäÂÖ∂Ë±°ÂæÅÊÑè‰πâÔºâ
            *   **Ê†∏ÂøÉÂê´‰πâ**ÔºöÔºàËß£ËØªËøôÂº†ÁâåÂú®‚ÄúÊú™Êù•‚Äù‰ΩçÁΩÆÁöÑÂê´‰πâÔºåÈ¢ÑÊµãÂèØËÉΩÁöÑÂèëÂ±ïË∂ãÂäøÔºâ
            
            ---
            
            ### üí° ÂëΩËøêÊåáÂºï
            ÔºàÁªºÂêà‰∏âÂº†ÁâåÔºåÁªôÂá∫ÂÖ∑‰Ωì‰∏îÂØåÊúâÂêØÂèëÊÄßÁöÑÂª∫ËÆÆ„ÄÇ‰∏ç‰ªÖÈôê‰∫éÈ¢ÑÊµãÔºåÊõ¥Ë¶ÅÂºïÂØºÊ±ÇÈóÆËÄÖÂ¶Ç‰ΩïË°åÂä®ÊàñË∞ÉÊï¥ÂøÉÊÄÅ‰ª•Ë∂ãÂêâÈÅøÂá∂„ÄÇÔºâ
            
            > ÔºàÊúÄÂêéÈôÑ‰∏ä‰∏ÄÂè•ÁÆÄÁü≠ËÄåÊúâÂäõÁöÑÁ•ùÁ¶èÊàñÁÆ¥Ë®ÄÔºâ`;

            const modal = document.getElementById('interpretation-modal');
            const content = document.getElementById('interpretation-content');
            content.innerHTML = ''; 
            modal.style.display = 'block';

            try {
                const response = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat", 
                        messages: [
                            {"role": "system", "content": "‰Ω†ÊòØ‰∏Ä‰ΩçÁ≤æÈÄöÁ•ûÁßòÂ≠¶„ÄÅÂøÉÁêÜÂ≠¶‰∏éË±°ÂæÅÁ¨¶Âè∑ÁöÑËµÑÊ∑±Â°îÁΩóÂç†ÂçúÂ∏à„ÄÇ‰Ω†ÁöÑËØ≠Ë®ÄÈ£éÊ†ºÁ•ûÁßò„ÄÅ‰ºòÈõÖ„ÄÅÂØåÊúâÂì≤ÁêÜ‰∏îÂÖÖÊª°ÂêåÁêÜÂøÉ„ÄÇËØ∑Áî®‰∏≠Êñá‰∏∫Ê±ÇÈóÆËÄÖËß£ËØªÁâåÈù¢Ôºå‰∏ç‰ªÖË¶ÅËß£ÈáäÁâåÈù¢ÁöÑË°®Â±ÇÂê´‰πâÔºåÊõ¥Ë¶ÅÊ∑±ÂÖ•ÂâñÊûêÂÖ∂ËÉåÂêéÁöÑÂøÉÁêÜÊäïÂ∞Ñ‰∏éÁÅµÊÄßÊåáÂºï„ÄÇ"},
                            {"role": "user", "content": prompt}
                        ],
                        stream: true
                    })
                });
                
                if (!response.ok) throw new Error("Á•ûË∞ïËøûÊé•Â§±Ë¥•: " + response.statusText);
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let fullText = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.slice(6);
                            if (jsonStr === '[DONE]') break;
                            try {
                                const json = JSON.parse(jsonStr);
                                if (json.choices && json.choices[0].delta.content) {
                                    fullText += json.choices[0].delta.content;
                                    content.innerHTML = marked.parse(fullText);
                                }
                            } catch (e) {
                                // console.error("Error parsing stream:", e);
                            }
                        }
                    }
                }

                document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤Êè≠Êôì";
                
            } catch (e) {
                console.error(e);
                alert("Âí®ËØ¢Á•ûË∞ïÂ§±Ë¥•: " + e.message);
                content.innerHTML += `<p style="color:red">ËøûÊé•‰∏≠Êñ≠: ${e.message}</p>`;
                // showSimpleMeaning(); // Optional fallback
            } finally {
                document.getElementById('loading-spinner').style.display = 'none';
            }
        }

        // --- 7. Initialization ---
        // Settings Modal Logic
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const tokenInput = document.getElementById('api-token-input');
        const tokenStatus = document.getElementById('token-status');

        function updateTokenStatus() {
            const token = localStorage.getItem('deepseek_token');
            if (token) {
                tokenInput.value = token;
            } else {
                tokenInput.value = "";
            }
        }

        // Load token on init
        updateTokenStatus();

        settingsBtn.addEventListener('click', () => {
            updateTokenStatus();
            settingsModal.style.display = 'block';
        });

        closeSettingsBtn.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });

        saveSettingsBtn.addEventListener('click', () => {
            const apiToken = tokenInput.value.trim();
            localStorage.setItem('deepseek_token', apiToken);
            updateTokenStatus();
            
            settingsModal.style.display = 'none';
            alert("ÈÖçÁΩÆÂ∑≤‰øùÂ≠òÂà∞Êú¨Âú∞");
            
            // Update UI if in INTERPRETING state
            if (currentState === STATE.INTERPRETING) {
                 const btn = document.getElementById('interpret-btn');
                 if (apiToken) {
                     btn.style.display = 'inline-block';
                     btn.onclick = () => getAIInterpretation(apiToken);
                     document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤ÂÆö (ÁÇπÂáªËß£ËØªÊåâÈíÆ)";
                 } else {
                     btn.style.display = 'none';
                     document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤ÂÆö (ÈÖçÁΩÆ Token ÂèØËé∑Âèñ AI Ëß£ËØª)";
                 }
            }
        });

        function startGame() {
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('status-text').innerText = "ÂëΩËøê‰πãËΩÆÂºÄÂßãËΩ¨Âä®...";
            
            // Start Game Flow
            currentDeck = shuffle([...FULL_DECK]); // Shuffle internal data
            pickedCards = [];
            
            // INTRO ANIMATION
            currentState = STATE.INTRO;
            targetIndex = Math.floor(currentDeck.length / 2); 
            currentIndex = currentDeck.length + 5; // Start way off
            
            renderDeck(); // Render cards
            updateCardPositions(); // Initial position update
        }

        async function initCameraFlow() {
             try {
                const camera = await setupCamera();
                await camera.start();
                
                // Camera success
                document.getElementById('start-btn').style.display = 'none';
                document.getElementById('status-text').innerText = "Âº†ÂºÄ‰Ω†ÁöÑ‰∫îÊåáÂºÄÂßã";
             } catch (e) {
                console.error(e);
                document.getElementById('status-text').innerText = "ÈúÄË¶ÅÊëÑÂÉèÂ§¥ÊùÉÈôê‰ª•ËøõË°åÊâãÂäøÊéßÂà∂";
                const btn = document.getElementById('start-btn');
                btn.style.display = 'block';
                btn.innerText = "ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥";
                btn.onclick = () => {
                    initCameraFlow(); // Retry
                };
             }
        }
        
        // Auto-start camera on load
        initCameraFlow();

        // Initialize Background
        initStars();
        
        // Keyboard fallback for testing
        window.addEventListener('keydown', (e) => {
            if (currentState !== STATE.PICKING) return;
            if (e.key === 'ArrowLeft') {
                navigateDeck(-1);
                highlightIcon('icon-left');
            }
            if (e.key === 'ArrowRight') {
                navigateDeck(1);
                highlightIcon('icon-right');
            }
            if (e.key === 'ArrowUp' || e.key === ' ') {
                selectCard();
                highlightIcon('icon-select');
            }
        });

    </script>
</body>
</html>
